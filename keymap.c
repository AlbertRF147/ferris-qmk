#include "keycodes.h"
#include "keymap_us.h"
#include <stdint.h>
#include QMK_KEYBOARD_H

/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

enum {
    TD_A_ESC,
    TD_SPC_DOT,
    TD_COMM_SCLN
};

enum layer_names {
    _BASE,
    _L1,
    _L2,
    _L3,
    _L4
};

enum custom_keycodes {
    SYM_OVERLAY_L = SAFE_RANGE,
    SYM_OVERLAY_R
};

static uint16_t sym_timer_left;
static uint16_t sym_timer_right;

// Tap Dance definitions
tap_dance_action_t tap_dance_actions[] = {
    // Tap once for Escape, twice for Caps Lock
    [TD_A_ESC] = ACTION_TAP_DANCE_DOUBLE( KC_A, KC_ESC ),
    [TD_SPC_DOT] = ACTION_TAP_DANCE_DOUBLE( KC_SPC, KC_DOT ),
    [TD_COMM_SCLN] = ACTION_TAP_DANCE_DOUBLE( KC_COMM, KC_SCLN ),
};

// clang-format off
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_BASE] = LAYOUT_split_3x5_2(
		KC_Q            ,	KC_W           ,	KC_E           ,	KC_R           ,	KC_T          ,	KC_Y          ,	KC_U          ,	KC_I            ,	KC_O           ,	KC_P        ,
		TD( TD_A_ESC )  ,	LSFT_T( KC_S ) ,	LCTL_T( KC_D ) ,	LGUI_T( KC_F ) ,	LALT_T( KC_G ),	RALT_T( KC_H ),	RGUI_T( KC_J ),	RCTL_T( KC_K )  ,	RSFT_T( KC_L ) ,	KC_TAB      ,
		KC_Z            ,	KC_X           ,	KC_C           ,	KC_V           ,	KC_B          ,	KC_N          ,	KC_M          ,	TD(TD_COMM_SCLN),	TD(TD_COMM_SCLN),	KC_CAPS_LOCK,
		LT( 4, KC_BSPC ),	SYM_OVERLAY_L,	SYM_OVERLAY_R,	LT( 3, KC_BSPC)
	),
    [_L1] = LAYOUT_split_3x5_2(
		KC_EXLM,	KC_AT  ,	KC_HASH,	KC_DLR ,	KC_PERC,	KC_CIRC,	KC_AMPR,	KC_ASTR,	KC_PLUS,	KC_QUES,
		KC_NO  ,	KC_TILD,	KC_DQUO,	KC_QUOT,	KC_BSLS,	KC_LT  ,	KC_LCBR,	KC_LPRN,	KC_LBRC,	KC_EQL ,
		KC_NO  ,	KC_MINS,	KC_UNDS,	KC_PIPE,	KC_PSLS,	KC_GT  ,	KC_RCBR,	KC_RPRN,	KC_RBRC,	KC_GRV ,
		KC_NO  ,	KC_ENT ,	KC_SPC ,	KC_BSPC
	),
    [_L2] = LAYOUT_split_3x5_2(
		KC_EXLM,	KC_AT  ,	KC_HASH,	KC_DLR ,	KC_PERC,	KC_CIRC,	KC_AMPR,	KC_ASTR,	KC_PLUS,	KC_QUES,
		KC_NO  ,	KC_TILD,	KC_DQUO,	KC_QUOT,	KC_BSLS,	KC_LT  ,	KC_LCBR,	KC_LPRN,	KC_LBRC,	KC_EQL ,
		KC_NO  ,	KC_MINS,	KC_UNDS,	KC_PIPE,	KC_PSLS,	KC_GT  ,	KC_RCBR,	KC_RPRN,	KC_RBRC,	KC_GRV ,
		KC_NO  ,	KC_ENT ,	KC_SPC ,	KC_BSPC
	),
    [_L3] = LAYOUT_split_3x5_2(
		KC_NO,	KC_NO,	KC_7 ,	KC_8 ,	KC_9,	KC_NO,	KC_NO,	KC_NO,	KC_NO,	KC_NO,
		KC_NO,	KC_NO,	KC_4 ,	KC_5 ,	KC_6,	KC_NO,	KC_NO,	KC_NO,	KC_NO,	KC_NO,
		KC_NO,	KC_0 ,	KC_1 ,	KC_2 ,	KC_3,	KC_NO,	KC_NO,	KC_NO,	KC_NO,	KC_NO,
		KC_NO,	KC_NO,	KC_NO,	KC_NO
	),
    [_L4] = LAYOUT_split_3x5_2(
		KC_NO,	KC_NO,	KC_NO,	KC_NO  ,	KC_NO,	KC_NO  ,	KC_PSCR,	KC_NO,	KC_NO   ,	KC_NO,
		KC_NO,	KC_NO,	KC_NO,	KC_NO  ,	KC_NO,	KC_LEFT,	KC_DOWN,	KC_UP,	KC_RIGHT,	KC_NO,
		KC_NO,	KC_NO,	KC_NO,	KC_NO  ,	KC_NO,	KC_NO  ,	KC_NO  ,	KC_NO,	KC_NO   ,	KC_NO,
		KC_NO,	KC_NO,	KC_NO,	KC_BSPC
	),
};
// clang-format on

static uint16_t hold_start_right = 0;
static bool overlay_right_active = false;
static uint16_t show_overlay_from_ms = 1000;

static bool handle_sym_overlay(bool pressed, uint16_t *timer_store, bool is_left) {
    uint8_t layer = is_left ? _L1 : _L2;
    uint16_t tap_key = is_left ? KC_ENT : KC_SPC;
    uint16_t *start = &hold_start_right;
    bool *overlay = &overlay_right_active;

    if (pressed) {
        *start = timer_read();
        *overlay = false;
        layer_on(layer);
    } else {
        layer_off(layer);
        if (*overlay) unregister_code(KC_F19);
        if (timer_elapsed(*start) < TAPPING_TERM) tap_code(tap_key);
        *start = 0;
        *overlay = false;
    }
    return false; // we handled everything, so caller should return false
}

void matrix_scan_user(void) {
    if (hold_start_right && !overlay_right_active
            && timer_elapsed(hold_start_right) > show_overlay_from_ms) {
        register_code(KC_F19);
        overlay_right_active = true;
    }
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {

        case SYM_OVERLAY_L:
            return handle_sym_overlay(record->event.pressed, &sym_timer_left, true);

        case SYM_OVERLAY_R:
            return handle_sym_overlay(record->event.pressed, &sym_timer_right, false);

    }

    return true;
}


#if defined( ENCODER_ENABLE ) && defined( ENCODER_MAP_ENABLE )
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {

};
#endif // defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)
